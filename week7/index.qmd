---
pagetitle: "ETC5513: Reproducible and Collaborative Practices"
subtitle: "Undoing, exporing and cleaning with git"
author: "Michael Lydeamore"
email: "michael.lydeamore@monash.edu"
date: "Week 7"
department: "Department of Econometrics and Business Statistics"
unit-url: "rcp.numbat.space"
footer: "ETC5513 Week 7"
format: 
  revealjs:
    logo: images/monash-stacked-blue-rgb-transparent.png
    slide-number: c
    multiplex: false
    theme: ../assets/monash.scss
    show-slide-number: all
    show-notes: false
    controls: true
    width: 1280
    height: 750
    css: [../assets/tachyons-addon.css, ../assets/custom.css, ../assets/lecture-01.css]
    include-after-body: "../assets/after-body.html"
    chalkboard:
      boardmarker-width: 5
      buttons: true
execute:
  echo: true
---

## 🧠 Today’s Goals

-   Learn how to safely undo and explore commits
-   Understand how to recover lost work
-   Get more comfortable with the Git timeline and history
-   Clean up messy projects

------------------------------------------------------------------------

## 🧠 Git Mental Model

Git works across three layers:

-   **Working Directory**: your actual files
-   **Index (Staging Area)**: what will be in your next commit
-   **HEAD (Repository)**: your last committed snapshot

Some examples: - `git add` moves changes → index - `git commit` moves index → HEAD - `git reset` moves HEAD pointer (soft/mixed/hard)

------------------------------------------------------------------------

## 🔁 Reverting and Resetting – Recap

### `git revert`

-   Creates a **new commit** that undoes a previous one
-   Safe on shared branches (e.g. `main`)

``` bash
git revert <commit-hash>
```

------------------------------------------------------------------------

### `git reset`

-   **Moves your branch pointer backward**
-   Can **rewrite history** (dangerous on shared branches!)
-   Options:
    -   `--soft`: Keep changes staged
    -   `--mixed`: Keep changes unstaged
    -   `--hard`: **Deletes changes**

``` bash
git reset --soft HEAD~1
```

------------------------------------------------------------------------

## 🧵 Detached HEAD

-   Happens when you check out a **specific commit**, not a branch
-   Useful for exploring history
-   If you make changes in this state, they can be lost unless you make a branch

------------------------------------------------------------------------

## 🧪 Demo: Detached HEAD + Branch

1.  In the terminal or Git pane:

``` bash
git log --oneline
```

2.  Copy a commit hash from earlier and run:

``` bash
git checkout <commit-hash>
```

You’re now in **detached HEAD**!

------------------------------------------------------------------------

### 🛟 Rescue Your Work

If you want to keep changes made in detached HEAD:

``` bash
git switch -c recovered-work
```

✅ This creates a new branch from that point!

------------------------------------------------------------------------

## ✍️ `git commit --amend`

Use this when you:

-   Made a typo in the last commit message
-   Forgot to include a file
-   Want to slightly edit the last commit

------------------------------------------------------------------------

## 🧪 Demo: Amending a Commit

1.  Make a small commit\
2.  Realize you forgot something\
3.  Stage the missing file, then run:

``` bash
git commit --amend
```

🎯 You can edit the message or leave it the same

⚠️ Avoid `--amend` if you’ve already pushed the commit

------------------------------------------------------------------------

## 🔍 `git reflog`

-   Shows **every move of HEAD** (including things Git log forgets)
-   Useful to **recover commits** after a reset or checkout

``` bash
git reflog
```

------------------------------------------------------------------------

### 🧪 Activity: Oops, I reset too far!

1.  Make a commit\
2.  Reset to a previous state:

``` bash
git reset --hard HEAD~1
```

3.  Run `git reflog` to find the lost commit\
4.  Use:

``` bash
git checkout <hash>
```

Then:

``` bash
git switch -c recovered-branch
```

🎉 You’ve recovered “lost” work!

------------------------------------------------------------------------

## 🗑️ `git rm`: Remove Files from the Repository

-   Use `git rm` to delete a **tracked** file from both your working directory and Git’s index.
-   Git will stage the deletion automatically.

``` bash
git rm filename.txt
git commit -m "Remove filename.txt"
```

✅ After this commit, the file will no longer exist in your working directory *or* the repository.

------------------------------------------------------------------------

## ❗ Why Not Just Delete the File?

-   If you delete a file in RStudio or your file browser:
    -   Git will show it as **"deleted: filename.txt"**
    -   But you still need to `git add` the deletion

``` bash
# After deleting manually:
git status         # Shows deletion
git add filename.txt
git commit -m "Remove file"
```

✅ `git rm` does both steps at once — it’s safer and cleaner

------------------------------------------------------------------------

## 💡 Recovering a Deleted File

If you **haven’t committed** the deletion yet:

``` bash
git restore filename.txt
```

If you **already committed** the deletion:

``` bash
git checkout HEAD~1 -- filename.txt
```

✅ Or use `git reflog` to find the commit where the file still existed

------------------------------------------------------------------------

## 🧾 `git rm --cached`: Keep the File, Remove It from Git

-   Use this when you've **added a file to Git by mistake**, but you don’t want to delete it from your computer
-   Git stops tracking it — but the file stays in your working directory

``` bash
git rm --cached data.csv
git commit -m "Stop tracking data.csv"
```

✅ The file will still be on disk, but not in the next commit

------------------------------------------------------------------------

## 🧠 Common Use Case

> You committed a large data file by accident

1.  Add the filename to `.gitignore`
2.  Run:

``` bash
git rm --cached data.csv
git commit -m "Remove data.csv from tracking"
```

3.  Push your changes\
4.  The file is now ignored and won’t be re-added

✅ Useful for cleaning up mistakes without losing the file

------------------------------------------------------------------------

## 🧹 `git clean`

-   Deletes **untracked files** (not in Git yet)
-   Helpful when switching branches or cleaning clutter

``` bash
git clean -n   # dry run
git clean -f   # permanently delete
```

------------------------------------------------------------------------

## ⚠️ Warning

-   `git clean` is **permanent**
-   You can’t undo it with `reflog` or reset
-   Always use `-n` first to preview

------------------------------------------------------------------------

## 🧪 Activity: Cleaning Up

1.  In RStudio, create a few new files **but don’t add them to Git**
2.  Run:

``` bash
git status
git clean -n
```

3.  If it looks right:

``` bash
git clean -f
```

✅ Now those untracked files are gone!

------------------------------------------------------------------------

## 🧠 When to Use What

| Situation                       | Use This             |
|---------------------------------|----------------------|
| Undo safely on shared branches  | `git revert`         |
| Clean up your last commit       | `git commit --amend` |
| Rewind local commit history     | `git reset`          |
| Accidentally reset or lost work | `git reflog`         |
| Delete untracked junk           | `git clean`          |

------------------------------------------------------------------------

## Questions?

-   When would you **not** use `reset`?
-   What does `reflog` help you find that `log` doesn’t?
-   Have you ever thought you lost work but actually didn’t?

------------------------------------------------------------------------