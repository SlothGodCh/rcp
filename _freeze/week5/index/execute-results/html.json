{
  "hash": "07a76008faacce9766ae0a2ada7e9a8f",
  "result": {
    "engine": "knitr",
    "markdown": "---\npagetitle: \"ETC5513: Reproducible and Collaborative Practices\"\nsubtitle: \"Deeper git knowledge, stashing and tools\"\nauthor: \"Michael Lydeamore\"\nemail: \"michael.lydeamore@monash.edu\"\ndate: \"Week 5\"\ndepartment: \"Department of Econometrics and Business Statistics\"\nunit-url: \"rcp.numbat.space\"\nfooter: \"ETC5513 Week 5\"\nformat: \n  revealjs:\n    logo: images/monash-stacked-blue-rgb-transparent.png\n    slide-number: c\n    multiplex: false\n    theme: ../assets/monash.scss\n    show-slide-number: all\n    show-notes: false\n    controls: true\n    width: 1280\n    height: 750\n    css: [../assets/tachyons-addon.css, ../assets/custom.css, ../assets/lecture-01.css]\n    include-after-body: \"../assets/after-body.html\"\n    chalkboard:\n      boardmarker-width: 5\n      buttons: true\nexecute:\n  echo: true\n---\n\n\n\n\n\n\n## <br>[ETC5513: Reproducible and Collaborative Practices]{.monash-blue .title} {#etc5513-title background-image=\"images/bg-01.png\"}\n\n### Deeper git knowledge, stashing and tools\n\nLecturer: *Michael Lydeamore*\n\nDepartment of Econometrics and Business Statistics\n\n::: tl\n<br>\n\n<ul class=\"fa-ul\">\n\n<li>\n\n[<i class=\"fas fa-envelope\"></i>]{.fa-li}michael.lydeamore@monash.edu\n\n</li>\n\n<li>\n\n[<i class=\"fas fa-calendar-alt\"></i>]{.fa-li} Week 5\n\n</li>\n\n<li>\n\n[<i class=\"fa-solid fa-globe\"></i>]{.fa-li}<a href=\"rcp.numbat.space\">rcp.numbat.space</a>\n\n</li>\n\n</ul>\n\n<br>\n:::\n\n## Open Frame\n\n![](images/kelly-sikkema-mdADGzyXCVE-unsplash.jpg){fig-align=\"center\"}\n\n## Recap\n\n* Learned more on creating reproducible reports:\n  - Referencing\n  - Talk about css files\n* More on Git:\n  - Branches\n* Solving Git merging conflicts\n* Install VSCode as a GUI to work with Git/GitHub and as a text editor for commits.\n\n## Today's plan {#aim}\n\n::: {.callout-important}\n\n## Aim\n1. More Git/GitHub tools\n2. Pull requests: a tool to collaborate with others via GitHub \n3. VSCode \n:::\n\nWith this you have learned the **basics** to [create]{.monash-green2} reproducible and collaborative reports.\n\n\n## Stashing\n\n\"Stashing takes the \"dirty\" state of your working directory - that is, your modified tracked files and staged changes - and saves it on a stack of unfinished changes that you can reapply at any time (even on a different branch).\" [Source](https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning)\n\n`git stash` comes in handy for staged files or `git stash -u for unstaged files.\n\n`git stash` allow us to keep changes in our local repository and to commit then later on.\n\n`git stash save \"Message\"` allow us to add a message to the stash\n\n## `git stash`\n\nCreating a stash allows you to revert but save changes that you might have done in the repository, without losing them.\n\nThen, when you are ready to include those changes and to commit them into the remote repo we can use:\n\n- `git stash apply` makes your changes in the stash on the branch _but keeps them in the stash_.\n- `git stash pop` makes your changes in the stash on the branch _and removes them from the stash_.\n\nGenerally, `pop` is preferred unless you have to apply your changes more than once.\n\n## `git stash` in practice\n\n```\n$ git status\nOn branch master\nChanges to be committed:\nnew file: style.css\nChanges not staged for commit:\nmodified: index.html\n```\n\n```\n$ git stash\nSaved working directory and index state WIP on master: \n5002d47 our new homepage\nHEAD is now at 5002d47 our new homepage\n```\n\n## git status changes after stashing\n\n```\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n## While your changes are stashed you can ... \n\n- Make more changes into the repo, create new commits, switch branches and perform any other Git operations.\n- You can come back to your stash later on and re-apply your stash when you're ready.\n- Stash is [local]{.monash-green2} to your repository. \n\n::: {.callout-important}\n`stash`es are not transferred to the server when you push.\n:::\n\nYou can create more than one stash: be careful with this.\n\n## `git apply` and `git pop`: stage changes\n\nThe `git stash` command takes your uncommitted changes but staged and  saves them away for later use, or `git stash -u` if we have not staged the changes, and then reverts them from your working copy. `git stash` save \"Message to remember what you did\"\n\nTo bring stash in from the repo:\n\n* `git stash apply`\n* `git stash pop`\n\n## `git stash apply`\n\n`git stash apply` will take the changes saved in your stash and apply them into the working directory of your current branch. In addition, the changes are kept in the stash. This might be useful when you want to apply the same changes into different branches.\n\n## `git stash pop`\n\n`git stash pop` will do the same as apply but _will delete the stash after applying the changes_. \n\n::: {.callout-important}\nThe stash is _not_ a replacement for a commit. You can think of stashing as 'keeping for later', while a commit is for saving and keeping record.\n:::\n\n\n## `git stash pop` in practice\n\n```\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n\n```\n$ git stash pop\nOn branch master\nChanges to be committed:\nnew file: style.css\nChanges not staged for commit:\nmodified: index.html\nDropped refs/stash@{0} (32b3aa1d185dfe6d57b3c3cc3)\n```\n\n## `git stash apply`  in practice\n\n```\ngit stash apply\nOn branch master\nChanges to be committed:\nnew file: style.css\nChanges not staged for commit:\nmodified: index.html\n```\n\n::: {.fragment}\nDo you see the difference between `pop` and `apply`?\n:::\n\n## More than one stash\n\n`git stash list` will list all of your stashes\n\n```\n$ git stash list\nstash@{0}: WIP on dev: 1f6f8bb Commit message A\nstash@{1}: WIP on master: 50cf63b Commit message B\n```\n\n- `git stash show stash@{1}` will show you the files changed in `stash@{1}`\n- Then  you can call `git stash apply/pop` twice\n- Or `git stash apply stash@{0}`\n- Or `git stash pop stash@{1}`\n\n## Deleting stash\n\n- `git stash drop stash@{0}` will delete `stash@{0}`\n- `git stash clear` will remove **all** the stashes in the stash area.\n\n::: {.callout-important}\nBecause stashes aren't synchronised, once they're gone they're gone. So, clear with caution.\n:::\n\n## Creating a branch from a stash\n\nIf you stash some work, leave it there for a while, and continue on the branch from which you stashed the work, you may have a problem reapplying the work. If the apply tries to modify a file that you’ve since modified, you’ll get a merge conflict and will have to try to resolve it. \n\nIf you want an easier way to test the stashed changes again, you can run `git stash branch branchname`, which creates a new branch for you with your selected branch name, checks out the commit you were on when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully.\n\n## Tracked, untracked and ignored files\n\nGit sees every file in your working copy as one of three things:\n\n- [tracked]{.monash-green2}: a file which has been previously staged or committed\n- [untracked]{.monash-green2}: a file which has not been staged or committed or\n- [ignored]{.monash-green2}: a file which Git has been explicitly told to ignore.\n\nTypically in a project there might be files that we decided to not track and ignore. \n\nExamples include files that are built artifacts and machine generated files that can be derived from your repository source or should otherwise not be committed.\n\n## In Rstudio  \n\n- [**Blue-M**]{style=\"color:blue\"}: a file that is already under version control that has been modified. \n- [**Orange-?**]{style=\"color:orange\"}: a file that is not under version control (yet...). \n- [**Green-A**]{style=\"color:green\"}: a file that was not under version control, but which has been staged to be committed \n- [**Red-D**]{style=\"color:red\"}: a file under version control has been deleted.  To make it really disappear, you have to staged its disappearance and commit. \n- [**Purple-R**]{style=\"color:purple\"}: a file that was renamed.  (Note that git in Rstudio seems to be figuring this out on its own.) \n\n## .gitignore\n\n[Ignored files]{.monash-green2} are tracked in a special file named `.gitignore` that is checked in at the root of your repository.\n\n- There is **no** explicit `git ignore` command: instead Git uses a `.gitignore` file which must be edited and committed by hand when you have new files that you wish to ignore.\n- `.gitignore` files contain special patterns which are comapred against filenames to determine whether or not they should be ignored.\n\n## Example of `gitignore` patterns\n\n![](images/gitignore.png){fig-align=\"center\"}\n\n[Source here](https://www.atlassian.com/git/tutorials/saving-changes/gitignore)\n\n## `.gitignore` file\n\n- You can use the characters as those in the table\n- You can also add comments inside your file using [#]{.monash-green2}\n\n```\n# ignore all logs\n*.log\n# History files\n.Rhistory\n.Rapp.history\n# Session Data files\n.RData\n# User-specific files\n.Ruserdata\n# Example code in package build process\n*-Ex.R\n```\n\n## Example of a gitignore file\n\n![](images/example_gitignore.png){fig-align=\"center\"}\n\n[Source here](https://gist.github.com/octocat/9257657)\n\n## Creating a gitignore file\n\n::: {.columns}\n::: {.column width='50%'}\nFrom the command line you can create a `.gitignore` file for your repository.\n\n`touch .gitignore`\n\nYou can edit the file using Rstudio or VSCode.\n\nYou can also create a `.gitignore` file from GitHub.\n\n::: {.fragment}\nYou can edit it later using RStudio or VSCode.\n:::\n\n:::\n::: {.column width='50%'}\n![](images/creatingrepo2.png){fig-align=\"center\"}\n\n:::\n:::\n\n## Creating a `.gitignore` file\n\nIf you want to ignore a file that **is already checked in**, you have to untrack it before you add it to the `.gitignore`.\n\nDo to this, from your terminal/Git Bash Shell:\n\n`$ git rm --cached FILENAME`\n\nThe `gitignore` file specifies intentionally untracked files to ignore.\n\nEach line in a gitignore file specifies a pattern.\n\n## Example of a `gitignore` file\n\n![](images/example_gitignore.png){fig-align=\"center\"}\n\n[Source here](https://gist.github.com/octocat/9257657)\n\n## Your branch is ahead of 'origin/master' by 1 commits {.smaller}\n\n- This message means that your local repository has one commit that hasn't been pushed yet.\n- If you push without committing, nothing gets pushed. \n- If you commit without adding, nothing gets committed. \n- If you add without committing, nothing at all happens, git merely remembers that the changes you added should be considered for the following commit.\n\n::: {.callout-tip}\n`git add` and `git commit` are [local operations]{.monash-green2}.\n\n`git push`, `git pull`, and `git fetch` are operations that interact with a remote repository.\n:::\n \n## Why do we fork a repository?\n\nA **fork** is a copy of a repository. \n\n- Forking a repository allows you to freely experiment with changes without affecting the original project.\n- Most commonly, forks are used to either propose changes to someone else project or to use someone else project as a starting point for your own project.0\n\n[More info here](https://help.github.com/en/github/getting-started-with-github/fork-a-repo)\n\n## Forking a repo  in GitHub\n\nSearch/navigate repo from within our Github account.\n\n![](images/fork.png){fig-align=\"center\"}\n\n## Forked repo \n\n![](images/forked.png){fig-align=\"center\"}\n\n## Our repos in GitHub\n\n![](images/repos.png){fig-align=\"center\"}\n\n## Differences between forking and cloning a repo {.smaller}\n\n- A fork is a copy of someone else GitHub repository, saved to your own GitHub. It allows you to experiment with changes without affecting the original project.\n- A fork acts as a bridge between the original repository and your personal one.\n- It will also allow you to interact between your forked copy and the original repo.\n\n::: {.fragment}\n-  When you clone a GitHub repository, you are creating a local copy of that repo on your computer. \n- That allows you to work on that repo locally and sync between both your local repo and your remote repo, but you cannot interact with the original repo if it's owned by someone else.\n:::\n\n## What is a Pull request?\n\n- We use GitHub to share our code and projects with others.\n- There are situations when another person makes changes into your code and wants you to consider those changes, for example fixing a bug or adding new examples\n\nTo do this, the other person can make a _pull request_. This makes a request to the repositories owner to pull or merge these changes into the original repository.\n\n## Pull request visually\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/pr0.jpg){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## Forked repo\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/pr1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## Modified forked repo for pull request\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/commit.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n\n## Create a pull request to the original repo\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/pr2.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## What happens when you start a pull request\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/pr3.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## Pull request from ETC5513demo to okayama1\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/pr4.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## Pull request to okayama1 (owner of original repo)\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/pr5.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n\n## Pull request email to okayama1\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/pr6.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## Pull request okayama1 GitHub Inbox\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/pr7.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n# Pull request okayama1 GitHub request received\n\n\n\n\n::: {.cell layout-align=\"center\" angle='180'}\n::: {.cell-output-display}\n![](images/pr8.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n# VSCode\n\n![](images/vscode_icon.png){fig-align=\"center\"}\n\n* VSCode is a powerful IDE that works across many different languages.\n* It also has excellent Git integration so we can track and create repos, branches, stage, commit and push files.\n* Make sure you log into VSCode using your GitHub account.\n\n## Opening VSCode\n\n![](images/vscode_git_create.jpg){fig-align=\"center\"}\n\n## Editing the README.md file\n\n![](images/vscode_readme_edit.jpg){fig-align=\"center\"}\n\n## Staged the  changes  README.md file\n\n![](images/vscode_git_stage.jpg){fig-align=\"center\"}\n\n\n## Commit the  changes  README.md file\n\n![](images/vscode_git_commit.jpg){fig-align=\"center\"}\n\n## Visualizing all the files\n\n![](images/vscode_git_tree.jpg){fig-align=\"center\"}\n\n\n## Creating new branch\n\n![](images/vscode_git_create_branch.jpg){fig-align=\"center\"}\n\n## In the meantime in GitHub\n\n![](images/vscode_git_branch_on_gh.jpg){fig-align=\"center\"}\n\n\n## Resolving conflicts\n\n![](images/vscode_merge_conflict_1.jpg){fig-align=\"center\"}\n\n## Resolving conflicts\n\n![](images/vscode_merge_conflict_2.jpg){fig-align=\"center\"}\n\n## Resolving conflicts\n\n![](images/vscode_merge_conflict_3.jpg){fig-align=\"center\"}\n\n## Resolving conflicts\n\n![](images/vscode_merge_conflict_4.jpg){fig-align=\"center\"}\n\n# Before the tutorial\n\n- Please make sure you have R and Rstudio locally installed\n\n- Please make sure that your GitHub is connected to VSCode and VSCode is installed. \n\n\n## What you should know by now?\n\n- Crate reproducible simple html reports.\n- Create figures and tables using R code chunks\n- Reference figures, tables and sections\n- Connect your reproducible reports to Git and GitHub (version control)\n- Work on a reproducible project using Rstudio, Git and GitHub\n- Create and merge branches\n- Being able to solve merging conflicts\n- Forking repos in GitHub\n- Interact with others using pull requests on GitHub\n- Basic operations with VSCode.\n\n# We have the scaffolding ready for collaborative and reproducible reporting\n\n\nWe are now set to start using this tools and create collaborative and reproducible reports!\nFrom now on we will learn more on creating beautiful and reproducible reports!\n\n## Tutorial and Next Lecture\n\nNext week we will discuss the importance of reproducible reporting and the usage of version control systems. We will do few hands on exercises so please make sure you bring your computer to the lecture.\n\n\n- Tutorial this week you will start working in pairs.\n- You will continue working in pairs in Week 6 too.\n- In Week 6, we'll keep of practicing all the things that we have learned so far.\n- This week and next will provide great opportunities for you to practice all the tools that we have learned so far!\n\n## Week 5 Lesson\n\n::: {.callout-important}\n\n## Recap\n1. More Git/GitHub tools\n2. Pull requests: a tool to collaborate with others via GitHub \n3. VSCode \n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}