{
  "hash": "2a33c68f87d9b393f91b573204bda7fe",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'ETC5513: Collaborative and Reproducible Practices'\nsubtitle: \"Tutorial 7\"\nauthor: \"Michael Lydeamore\"\ndate: today\nformat:\n    unilur-html:\n        output-file: index.html\n        embed-resources: true\n    unilur-html+solution:\n        output-file: solution.html\n        embed-resources: true\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n# Cleaning Up Your Commit History  \n### With `git commit --amend` and Squashing via Rebase\n\n## 🧭 Goal\n\nLearn how to rewrite your commit history in Git using:\n\n- `git commit --amend` to fix the **last** commit\n- `git rebase -i` to **squash** multiple commits into one\n\n---\n\n## 1️⃣ Create and Clone a Repo\n\n### On GitHub\n\n1. Create a new repository:  \n   ```\n   git-history-cleanup\n   ```\n2. ✅ Check \"Add a README file\"\n\n---\n\n### In RStudio\n\n1. Go to **File → New Project → Version Control → Git**\n2. Paste the repo URL (SSH or HTTPS)\n3. Choose a location and click **Create Project**\n\n✅ You're now working in a Git-tracked project.\n\n---\n\n## 2️⃣ `--amend`: Edit Your Last Commit\n\n### Step 1: Add a New File\n\n1. Go to **File → New File → Quarto Document**\n2. Give it a name like: `report.qmd`\n3. In the file, add some content, for example:\n   ```markdown\n   # My Report\n\n   This is the first version.\n   ```\n\n4. Save the file  \n5. In the **Git pane**, stage and commit with the message:  \n   `\"Initial commit\"`\n\n---\n\n### Step 2: Realise You Forgot Something\n\n1. Add another line, such as:\n   `This line was accidentally left out.`\n\n2. Save the file  \n3. Stage the change  \n4. In the terminal, run:\n\n```bash\ngit commit --amend\n```\n\n💬 You can edit the commit message if you like — or keep it the same.\n\n✅ The most recent commit now includes both changes.\n\n---\n\n## 3️⃣ Squash Commits with Interactive Rebase\n\nLet’s now try squashing a few commits into one clean one.\n\n---\n\n### Step 1: Make a Messy Commit History\n\n1. Edit your `.qmd` file and make **3 separate commits**:\n\n   - Add a new section or chunk → commit: `\"Add section\"`\n   - Fix a typo → commit: `\"Fix typo\"`\n   - Add a final comment → commit: `\"Add footnote\"`\n\n✅ Commit after each change using the Git pane or terminal.\n\n---\n\n### Step 2: Check Your Commit History\n\nRun in the Terminal:\n\n```bash\ngit log --oneline\n```\n\nYou should see something like:\n\n```\nc3d4e5f Add footnote\nb2c3d4e Fix typo\na1b2c3d Add section\n...\n```\n\n---\n\n### Step 3: Start an Interactive Rebase\n\n```bash\ngit rebase -i HEAD~3\n```\n\nYou’ll see:\n\n```\npick a1b2c3d Add section\npick b2c3d4e Fix typo\npick c3d4e5f Add footnote\n```\n\n---\n\n### Step 4: Squash the Commits\n\nChange it to:\n\n```\npick a1b2c3d Add section\nsquash b2c3d4e\nsquash c3d4e5f\n```\n\nSave and write a new combined commit message like:\n\n```\nAdd section with typo fix and footnote\n```\n\nSave again to finish the rebase.\n\n---\n\n### Step 5: Confirm It Worked\n\nRun:\n\n```bash\ngit log --oneline\n```\n\n✅ You should now see **one clean commit** where there were three.\n\n---\n\n## 🧠 Reflect\n\n- Why is `--amend` useful when working on a single file?\n- When is it good practice to squash commits?\n- What would happen if you did this after pushing?\n\n---\n\n## ✅ Summary\n\n| Action                     | Command                            |\n|----------------------------|-------------------------------------|\n| Fix your last commit       | `git commit --amend`               |\n| Combine multiple commits   | `git rebase -i HEAD~N`             |\n| Keep your history clean    | Use these **before pushing**       |\n\n🎉 You’ve just learned to write cleaner, more professional commit histories!\n\n---\n\n# 🔁 Extension Activity: Merge vs Rebase\n\n## 🧭 Goal\n\nUnderstand the difference between `git merge` and `git rebase` by applying both to the same branches and comparing the result.\n\n---\n\n## 1️⃣ Setup: Create a Feature Branch\n\nIn your GitHub-connected RStudio project:\n\n1. Create a file: `experiment.R`\n2. Add one line:\n   ```\n   Main branch version\n   ```\n3. Save, stage, and commit:\n   ```\n   \"Add base file on main\"\n   ```\n\n4. Create a new branch called `feature`:\n\n```bash\ngit switch -c feature\n```\n\n---\n\n## 2️⃣ Add Work on the Feature Branch\n\n1. Edit `experiment.R` again:\n   ```\n   Feature branch addition\n   ```\n\n2. Save and commit:\n   ```\n   \"Add feature content\"\n   ```\n\n✅ You now have two commits on separate branches.\n\n---\n\n## 3️⃣ Add a Change to `main`\n\n1. Switch back to `main`:\n\n```bash\ngit switch main\n```\n\n2. Add to the file again:\n   ```\n   Main branch additional note\n   ```\n\n3. Save and commit:\n   ```\n   \"Add note on main branch\"\n   ```\n\n---\n\n## 📊 At This Point...\n\nYour Git history looks like this:\n\n```text\n          A---B  (feature)\n         /\n    ---O---C  (main)\n```\n\n- `O` = Original commit\n- `A` = Feature commit\n- `C` = Main branch commit\n- `B` = We'll merge or rebase next\n\n---\n\n## 4️⃣ Option A: Merge the Feature Branch\n\n```bash\ngit merge feature\n```\n\nYou’ll get a **merge commit**, like this:\n\n```text\n          A---B  (feature)\n         /     \\\n    ---O---C-----M  (main)\n```\n\n✅ History shows a clear branching path and merge point.\n\n---\n\n## 5️⃣ Option B: Try It Again with Rebase\n\n> This will recreate the same setup and use `rebase` instead of `merge`.\n\n1. Reset the last merge:\n\n```bash\ngit reset --hard HEAD~1\n```\n\n2. Switch to the `feature` branch:\n\n```bash\ngit switch feature\n```\n\n3. Rebase it onto `main`:\n\n```bash\ngit rebase main\n```\n\n4. Now go back to `main` and fast-forward:\n\n```bash\ngit switch main\ngit merge feature\n```\n\n---\n\n## 📊 After Rebase\n\nYour Git history now looks like:\n\n```text\n    ---O---C---A'  (main, feature)\n```\n\n- `A'` is a new version of A, replayed on top of C\n- No merge commit needed — linear history\n\n---\n\n## 🧠 Reflect\n\n* What’s the key difference between `merge` and `rebase`?  \n* Which history is easier to read?  \n* When is a merge preferred?  \n* Why must you be careful rebasing pushed commits?  \n\n---\n\n## ✅ Summary\n\n| Action                     | Result                            |\n|----------------------------|------------------------------------|\n| `git merge feature`        | Preserves both branches + merge commit |\n| `git rebase main` (on feature) | Rewrites feature history as linear |\n| Use `merge` after pushing  | ✅ Safe for shared work |\n| Use `rebase` before pushing | ✅ Keeps history clean |\n\n🎉 You've now seen both strategies in action — use the right one for the right job!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}