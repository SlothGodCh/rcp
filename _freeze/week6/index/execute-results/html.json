{
  "hash": "242d152f908c51710c7096bd0f799776",
  "result": {
    "engine": "knitr",
    "markdown": "---\npagetitle: \"ETC5513: Reproducible and Collaborative Practices\"\nsubtitle: \"Reproducible reporting and version control systems\"\nauthor: \"Michael Lydeamore\"\nemail: \"michael.lydeamore@monash.edu\"\ndate: \"Week 6\"\ndepartment: \"Department of Econometrics and Business Statistics\"\nunit-url: \"rcp.numbat.space\"\nfooter: \"ETC5513 Week 6\"\nformat: \n  revealjs:\n    logo: images/monash-stacked-blue-rgb-transparent.png\n    slide-number: c\n    multiplex: false\n    theme: ../assets/monash.scss\n    show-slide-number: all\n    show-notes: false\n    controls: true\n    width: 1280\n    height: 750\n    css: [../assets/tachyons-addon.css, ../assets/custom.css, ../assets/lecture-01.css]\n    include-after-body: \"../assets/after-body.html\"\n    chalkboard:\n      boardmarker-width: 5\n      buttons: true\nexecute:\n  echo: true\n---\n\n\n\n\n\n\n## <br>[ETC5513: Reproducible and Collaborative Practices]{.monash-blue .title} {#etc5513-title background-image=\"images/bg-01.png\"}\n\n### Reproducible reporting and version control systems\n\nLecturer: *Michael Lydeamore*\n\nDepartment of Econometrics and Business Statistics\n\n::: tl\n<br>\n\n<ul class=\"fa-ul\">\n\n<li>\n\n[<i class=\"fas fa-envelope\"></i>]{.fa-li}michael.lydeamore@monash.edu\n\n</li>\n\n<li>\n\n[<i class=\"fas fa-calendar-alt\"></i>]{.fa-li} Week 6\n\n</li>\n\n<li>\n\n[<i class=\"fa-solid fa-globe\"></i>]{.fa-li}<a href=\"rcp.numbat.space\">rcp.numbat.space</a>\n\n</li>\n\n</ul>\n\n<br>\n:::\n\n## Open Frame\n\n![](images/kelly-sikkema-mdADGzyXCVE-unsplash.jpg){fig-align=\"center\"}\n\n## Recap\n\n1. More Git/GitHub tools\n2. Pull requests: a tool to collaborate with others via GitHub \n3. VSCode \n\n## Today's plan {#aim}\n\n::: {.callout-important}\n\n## Aim\n* Learn about `git rebase`\n* Learn about `git fetch` and `git merge`\n* Learn about staging and unstaging files\n* Learn how to undo some changes\n:::\n\n## Rebase\n\nIn git, there are two main ways to integrate changes from one branch into another:\n\n1. `git merge`\n2. `git rebase`\n\n## Merging branches using `git merge`\n\nIf we use `git merge` to combine diverging branches, we will have a non-linear history.\n\n::: {.columns}\n::: {.column width='50%'}\n![](images/mergingbranches1.png){fig-align=\"center\"}\n\n:::\n::: {.column width='50%'}\n![](images/mergingbranches2.png){fig-align=\"center\"}\n\n:::\n:::\n\n::: {.callout-note}\n## Question\n\nIn which situation can we merge branches and have a _linear_ history?\n:::\n\n## Rebase\n\nRebasing is the process of moving or combining a sequence of commits from a branch onto another branch.\n\n* Rebasing is most useful and easily visualised in the context of a feature branching workflow\n* Rebasing changes the _base_ of your branch from one commit to another, making it appear as though you'd created your branch from a different commit.\n\n::: {.callout-important}\nRebasing moves an entire branch to another location in the repository\n:::\n\nIt can create a cleaner history if you don't want merge lines everywhere.\n\n## Rebase in practice {.smaller}\n\nAssume the following history exists and the current branch is `feature`:\n\n```\n          E<---F<---G feature\n         /\n    A<---B<---C<---D main\n```    \n\nIf we want to rebase the commits in the `feature` branch into the main branch, we need to do the following:\n\n::: {.columns}\n::: {.column width='50%'}\n* `git checkout feature` *and*\n* `git rebase main`\n\nor\n\n* `git rebase main feature`\n:::\n::: {.column width='50%'}\n```\n        feature    E'<--F'<--G' \n                  /\n A<---B<---C<---D main\n ```\n:::\n:::\n\n::: {.center .fragment}\n\nwhich results in:\n\n ```\n    A<---B<---C<---D<---E'<--F'<--G' main\n ```\n:::\n\n## Rebasing can be dangerous\n\n![](images/rebase.png){fig-align=\"center\"}\n\n## Git rebase and merge\n\n* Merging is a non-destructive operation. The existing branches are not changed in any way, and this avoids all the potential problems of rebasing.\n\n* Rebasing moves the entire `feature` branch to begin on the tip of the main branch, incorporating all of the new commits into main.\n* Rebasing rewrites the project history by creating brand new commits for each commit in the original branch, giving a cleaner history\n* _However_, this creates problems with safety and traceability\n\n::: {.callout-caution}\n## Golden rule for `rebase`\n\nNever use it on public branches (such as `main`) in collaborative projects.\n:::\n\n## More on branching\n\nImagine that you are working on your local repository and  a collaborator has created a new branch in your remote repo.\nYou are currently working on your local repo and want to have a look at the new branch. That means that the local repo and your remote repo have [diverged]{.monash-green2}. That is, both the local and remote repositories are **not currently synchronized.**\n\n\n- To synchronize your work: `git fetch origin`\n- `git fetch origin` looks where `origin` is and fetches any data from it that you don‚Äôt yet have.\n- It also updates your local database repo, moving your origin/main pointer (HEAD) to its new, more up-to-date position. [However, it does not move the HEAD of your local repository]{.monash-green2}\n\n## About remotes\n\nNote: If a git repo contains more than one `remote`, then `git fetch` will fetch all the changes from **all** remotes.\n\nTo fetch only one, use `git fetch origin` (or whatever remote you are after).\n\n\n# Why use fetch?\n\n![](images/fetch1.png){fig-align=\"center\"}\n\n`origin/main` is the remote tracking branch, which provides information about where the main branch is in origin\n\n## How does fetch work?\n \n![](images/fetch2.png){fig-align=\"center\"}\n\n`git fetch` downloaded the new B commit however our local working directory is not updated, and the head of our main branch is still pointing to commit A.\n\n## How do we merge those branches?\n\nWe need to combined main branch with the remote tracking origin/main branch. How?\n\n::: {.fragment}\n#### By merging! {.center}\n:::\n\n::: {.fragment}\nFirst, we need to move in the `main` branch and then merge `origin/main`\n\n```\ngit checkout main\ngit merge origin/main\n```\n:::\n\n::: {.fragment}\nIf the branches have not diverged, we can merge without conflict via a 'fast merge'.\n\nIf the branches have diverged, we will need to resolve conflicts.\n\nYou can check the status of the local and remote branches by using `git branch -vv`\n:::\n\n## Very useful commands for fetching\n\n- `git remote` lets you create, view, and delete connections to remote repositories.\n- `git branch -vv` allows you to check the status of your local and remote branches in relation to each other.\n- `git fetch` `origin` fetches the changes from remote origin\n- `git branch -a` lists all the branches available in the local repository +  all the branches fetched from the remote. \n\n::: {.callout-tip}\nThe branches fetched from the remote origin would be preceded by remotes/origin/\n:::\n\n## Undoing an error\n\nNot everything we do on a project will be worth keeping. We've seen already one way to undo some work (`git stash`). But, that relies on not having already committed the changes.\n\nWhat if we've made a commit, and then realise we don't want that commit anymore?\n\n::: {.fragment}\n#### We can reset {.center}\n:::\n\n::: {.fragment}\n#### Or revert {.center}\n:::\n\n## Undoing an error\n\nFirst, we should discuss `checkout`. We've talked alot about `HEAD` - that's the current pointer of the repository.\n\nWe've seen `git checkout` before too: When swapping between branches!\n\nFundamentally, branches are just commits with a slightly different pointer. That means, we can `checkout` to a specific commit.\n\n::: {.fragment}\nOne option to go backwards on the git tree and make a new set of changes is to `checkout` to a commit hash, make the new changes, and then push and manage the merge conflicts.\n:::\n\n## Undoing an error\n\nHere's our git tree:\n\n```\n(a) --- (b) --- (c) --- (d) <- HEAD, main\n```\n\n::: {.fragment}\n\nWhen we checkout `b`, our git tree changes to:\n\n```\n(a) --- (b) --- (c) --- (d) <- main\n          \\ \n          HEAD\n```\n:::\n\n::: {.fragment}\nNote that doing this will create _diverging histories_ and so is generally to be avoided. You _can_ overwrite history using `git push -f`, but this is really discouraged.\n:::\n\n## Reset or Revert\n\nThere are two ways to change commit history of a repository: `reset` and `revert`.\n\n::: {.callout-tip}\nGenerally, `reset` is for when the commit isn't public, and `revert` is when you've already made a public commit.\n:::\n\n::: {.fragment}\nThis is because `reset` changes the commit history, and `revert` does not.\n:::\n\n\n## üõë Two Very Different Tools\n\n| Command      | What it does                          | Safe on shared branches? |\n|--------------|---------------------------------------|---------------------------|\n| `git revert` | Adds a new commit that undoes changes | ‚úÖ Yes                    |\n| `git reset`  | Moves branch pointer (can erase commits) | ‚ùå Use with caution       |\n\n---\n\n## üîÅ `git revert`\n\n- Safely **undoes a specific commit**\n- Leaves history intact\n- Perfect for undoing mistakes on **main** or shared branches\n\n```bash\ngit revert <commit-hash>\n```\n\n---\n\n## ‚úçÔ∏è `git revert` Example\n\nYou added a bad commit:\n\n```bash\ngit log --oneline\n```\n\nFind the commit to undo, then:\n\n```bash\ngit revert abc1234\n```\n\n‚úÖ Creates a **new commit** that reverses the changes\n\n---\n\n## üßπ `git reset`\n\n- Rewrites history ‚ö†Ô∏è  \n- Used to **go back in time**  \n- 3 types: `--soft`, `--mixed`, `--hard`\n\n```bash\ngit reset --hard HEAD~1\n```\n\n---\n\n## üß™ Reset Variants\n\n### `--soft`\n- Undo commit, keep staged changes\n\n```bash\ngit reset --soft HEAD~1\n```\n\n### `--mixed` (default)\n- Undo commit, keep **unstaged** changes\n\n```bash\ngit reset HEAD~1\n```\n\n### `--hard`\n- ‚ö†Ô∏è DANGEROUS: Lose commits *and* file changes\n\n```bash\ngit reset --hard HEAD~1\n```\n\n---\n\n\n## üîç Visualizing [Revert]{style=\"color: green\"} vs Reset\n\nOriginal history:\n\n```\nA --- B --- C --- D   (main)\n```\n\n::: {.fragment}\nYou realize C introduced a bug...\n\n```\ngit revert C:\n\nA --- B --- C --- D --- E   ‚Üê E undoes the changes from C\n```\n:::\n\n::: {.fragment}\nHistory stays intact ‚úîÔ∏è\n:::\n\n## üîç Visualizing Revert vs [Reset]{style=\"color: green\"}\n\nOriginal history:\n\n```\nA --- B --- C --- D   (main)\n```\n\n::: {.fragment}\nYou realize C introduced a bug...\n\n```\ngit reset --hard B:\n\nA --- B   (main rewound ‚Äî commits C and D are gone!) ‚ö†Ô∏è\n```\n\n:::\n\n::: {.fragment}\nHistory is rewritten üö®\n:::\n\n## üß† When to Use Which?\n\n| Situation                              | Use `revert` | Use `reset` |\n|----------------------------------------|--------------|-------------|\n| You're on `main` or working with others | ‚úÖ Yes       | ‚ùå No        |\n| You need to undo a public commit        | ‚úÖ Yes       | ‚ùå No        |\n| You're cleaning up your own history     | ‚ùå No        | ‚úÖ Yes       |\n| You want to fix a commit but keep edits | ‚ùå No        | ‚úÖ (soft/mixed) |\n\n---\n\n## üí° Pro Tips\n\n- Always check `git log` before undoing!\n- Use `reset` only on branches you haven't shared\n- Use `revert` when you need a safe undo that keeps history\n\n## Week 6 Lesson\n\n::: {.callout-important}\n\n## Recap\n* Learn about `git rebase`\n* Learn about `git fetch` and `git merge`\n* Learn about staging and unstaging files\n* Learn how to undo some changes\n:::\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}