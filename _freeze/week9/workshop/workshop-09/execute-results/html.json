{
  "hash": "b1d64040cf9193509dc9f72bb244d7ad",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'ETC5513: Collaborative and Reproducible Practices'\nsubtitle: \"Workshop 9\"\nauthor: \"Michael Lydeamore\"\ndate: today\nformat:\n   html:\n      embed-resources: true\n      output-file: \"index.html\"\n      toc: true\n---\n\n::: {.cell}\n\n:::\n\n\n\n# Workshop: Finding and Fixing a Bug with `git bisect`\n\n## Objective:\nIn this workshop, you will practice using `git bisect` to identify the commit that introduced a bug into a repository. You will also make a pull request to fix the bug once you've found it.\n\n## Pre-requisite:\nBefore beginning, make sure you have:\n- Forked the repository [git-bisect-demo](https://github.com/mikelydeamore/git-bisect-demo) into your own GitHub account.\n- Cloned the repository from your fork to your local machine.\n\n---\n\n## Step 1: Fork the Repository\n\n1. Go to the [git-bisect-demo repository](https://github.com/mikelydeamore/git-bisect-demo).\n2. In the top-right corner, click the **Fork** button to create your own copy of the repository on GitHub.\n3. After forking, clone your fork to your local machine using the following command:\n\n   ```bash\n   git clone https://github.com/<your-username>/git-bisect-demo.git\n   ```\n\n4. Navigate to the cloned repository:\n\n   ```bash\n   cd git-bisect-demo\n   ```\n\n---\n\n## Step 2: Start the `git bisect` Workflow\n\n1. The `git-bisect-demo` repository contains a bug in the `square()` function. Your task is to identify the commit that introduced the bug using `git bisect`.\n\n2. Begin by starting the `git bisect` process:\n\n   ```bash\n   git bisect start\n   ```\n\n3. Mark the current (bad) commit:\n\n   Since the latest commit has the bug in it (the `square()` function is broken), we will mark it as `bad`:\n\n   ```bash\n   git bisect bad\n   ```\n\n4. Identify a good commit:\n\n   The `square()` function was working correctly before the bug was introduced. To identify a \"good\" commit, we need to mark a commit before the bug was introduced. You can look at the GitHub history or use `git log` to find a commit before the bug was introduced (for example, commit 10).\n\n   ```bash\n   git bisect good <commit-hash>\n   ```\n\n   - Replace `<commit-hash>` with the hash of a known good commit (such as the initial commit or the last commit before the bug was introduced).\n\n---\n\n## Step 3: Bisecting the Commits\n\n1. Now, Git will automatically check out a commit halfway between the good and bad commits. Your job is to test whether the bug is present in this commit.\n\n   - Open the `script.R` file and inspect the code. If the bug is present, mark the commit as `bad`:\n\n     ```bash\n     git bisect bad\n     ```\n\n   - If the bug is **not** present, mark the commit as `good`:\n\n     ```bash\n     git bisect good\n     ```\n\n2. Git will continue to narrow down the commits by checking out commits halfway between the last `good` and `bad` marks. Repeat the process of inspecting the code and marking each commit as either `good` or `bad` until Git identifies the commit that introduced the bug.\n\n---\n\n## Step 4: Fix the Bug\n\n1. Once the commit has been identified, you should make a branch from that point to fix the bug.\n\n   ```bash\n   git switch -C fix-square-bug\n   ```\n\n2. Open the `script.R` file and modify the `square()` function to correct the bug:\n\n   ```r\n   square <- function(x) {\n     return(x * x)  # Fix the bug (it was previously x + x)\n   }\n   ```\n\n3. Commit the fix:\n\n   ```bash\n   git add script.R\n   git commit -m \"Fix bug in square function\"\n   ```\n\n4. Push the changes to GitHub:\n\n```bash\ngit push origin fix-square-bug\n```\n\n---\n\n## Step 5: Complete the Bisect and Create a Pull Request\n\n1. End the `git bisect` session:\n\n   ```bash\n   git bisect reset\n   ```\n\n2. Push your changes to your GitHub fork:\n\n   ```bash\n   git push origin master\n   ```\n\n3. Go to your GitHub repository and create a **Pull Request** from your fork's `master` branch to the original repository (`mikelydeamore/git-bisect-demo`).\n\n   - Make sure to provide a detailed description in the pull request, explaining:\n     - The bug that was fixed.\n     - The process you used to find the bug using `git bisect`.\n     - The fix you made.\n\n---\n\n## Tips:\n- If you're not sure which commit is good or bad, use `git log` to help you identify the commit hashes.\n- If you make a mistake or want to change your `good`/`bad` marks, use `git bisect reset` to start the process over.\n- Don't forget to push your changes to your fork after fixing the bug!\n\n---\n\n## Conclusion\n\nIn this workshop, you learned how to use `git bisect` to find the commit that introduced a bug in a Git repository. You also learned how to fix the bug and create a pull request with your fix. This process is very useful for debugging and narrowing down the source of issues in large codebases.\n\n---\n\n### **Advanced Exercise: Create a Script for Git Bisect Testing**\n\nIn this exercise, you'll write a test script that automatically checks for the bug in the `square` function, which you can use during the `git bisect` process. This script will be used to help you determine the exact commit that introduced the bug.\n\n#### **Steps:**\n\n1. **Understand the Bug**\n   - The bug is that the `square` function produces incorrect results for certain inputs, and you'll need to test it during the `git bisect` process.\n\n2. **Create a Test Script for Bisect**\n   - Create a new file called `test-bisect.R` in the repository. This file will contain an R script for testing the bug. It will return `0` (success) if the bug is **not present** and `1` (failure) if the bug **is present**. `git bisect` uses this exit code to determine whether to continue searching in the good or bad commit range.\n\n3. **Write the Bisect Test Script**\n   - The script should check the functionality of the `square` function. For the purposes of this exercise, assume the bug is present when the result of `square(2)` is not equal to `4`.\n\n```R\nsource(\"script.R\")\nresult <- square(2)\n\nif (result != 4) {\n\tquit(status = 1)\n} else {\n\tquit(status = 0)\n}\n```\n\n#### **Explanation of the Script:**\n\n- This script runs an R command using `Rscript`, sources the `script.R` file, calls the `square` function with an input of `2`, and checks if the result is `4`.\n- If the result is not `4`, the script exits with a status code of `1`, which signals `git bisect` that the bug is present in the current commit (bad commit).\n- If the result is `4`, the script exits with a status code of `0`, signaling that the commit is \"good\".\n\n4. **Run `git bisect`**\n   - Now, you can start `git bisect` using the following commands:\n\n```bash\n# Start the bisect process by specifying a good commit and a bad commit\ngit bisect start\ngit bisect bad # This marks the current commit as bad (contains the bug)\ngit bisect good <commit-hash> # This marks an older commit as good (before the bug)\n\n# Use the bisect_test.sh script to automatically test each commit\ngit bisect run Rscript test-bisect.R\n```\n\n6. **Interpreting the Results**\n   - `git bisect` will automatically check each commit in the range between the good and bad commits by using the `bisect_test.sh` script. When the process finishes, `git bisect` will tell you the first bad commit where the bug was introduced.\n   - Once the bisect process completes, run the following command to reset the repository to its original state:\n\n```bash\ngit bisect reset\n```\n\n7. **Check whether the automatic bisect has worked**\n\nCheck the contents of `script.R` and see if you have found the bug. If not, you may need to modify `test-bisect.R` to better capture the case where the bug is present!\n\n---\n",
    "supporting": [
      "workshop-09_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}